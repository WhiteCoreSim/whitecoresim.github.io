<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>WhiteCore-Sim: WhiteCore.BotManager.AStar.Heap Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WhiteCore-Sim
   </div>
   <div id="projectbrief">An Open Source Virtual World Server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">WhiteCore.BotManager.AStar.Heap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a> allows to maintain a list sorted as long as needed. If no IComparer interface has been provided at construction, then the list expects the Objects to implement IComparer. If the list is not sorted it behaves like an ordinary list. When sorted, the list's "Add" method will put new objects at the right place. As well the "Contains" and "IndexOf" methods will perform a binary search.  
 <a href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for WhiteCore.BotManager.AStar.Heap:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.png" usemap="#WhiteCore.BotManager.AStar.Heap_map" alt=""/>
  <map id="WhiteCore.BotManager.AStar.Heap_map" name="WhiteCore.BotManager.AStar.Heap_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bd884c3d4826e1d566fbca5a63afa65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a4bd884c3d4826e1d566fbca5a63afa65">Add</a> (object obj)</td></tr>
<tr class="memdesc:a4bd884c3d4826e1d566fbca5a63afa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Adds the object at the right place.  <a href="#a4bd884c3d4826e1d566fbca5a63afa65">More...</a><br /></td></tr>
<tr class="separator:a4bd884c3d4826e1d566fbca5a63afa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c6e8ddd1a1953168ccd04cc343d308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a30c6e8ddd1a1953168ccd04cc343d308">AddRange</a> (ICollection coll)</td></tr>
<tr class="memdesc:a30c6e8ddd1a1953168ccd04cc343d308"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects will be added at the right place.  <a href="#a30c6e8ddd1a1953168ccd04cc343d308">More...</a><br /></td></tr>
<tr class="separator:a30c6e8ddd1a1953168ccd04cc343d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43688c29ebea70bc234c39fab7de8af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a43688c29ebea70bc234c39fab7de8af5">Clear</a> ()</td></tr>
<tr class="memdesc:a43688c29ebea70bc234c39fab7de8af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a43688c29ebea70bc234c39fab7de8af5">More...</a><br /></td></tr>
<tr class="separator:a43688c29ebea70bc234c39fab7de8af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc47c6f9c9465558869d4d1c0a357db"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9cc47c6f9c9465558869d4d1c0a357db">Clone</a> ()</td></tr>
<tr class="memdesc:a9cc47c6f9c9465558869d4d1c0a357db"><td class="mdescLeft">&#160;</td><td class="mdescRight">ICloneable implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a9cc47c6f9c9465558869d4d1c0a357db">More...</a><br /></td></tr>
<tr class="separator:a9cc47c6f9c9465558869d4d1c0a357db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fceb7f39ee8ceee1f502e1903db26b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a3fceb7f39ee8ceee1f502e1903db26b2">Contains</a> (object obj)</td></tr>
<tr class="memdesc:a3fceb7f39ee8ceee1f502e1903db26b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Search for a specified object in the list. If the list is sorted, a &lt;see cref = &quot;ArrayList.BinarySearch&quot;&gt;BinarySearch&lt;/see&gt; is performed using IComparer interface. Else the &lt;see cref = &quot;Equals&quot;&gt;Object.Equals&lt;/see&gt; implementation is used.  <a href="#a3fceb7f39ee8ceee1f502e1903db26b2">More...</a><br /></td></tr>
<tr class="separator:a3fceb7f39ee8ceee1f502e1903db26b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeae965977197f0b6934cbcab2ff38d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#afeae965977197f0b6934cbcab2ff38d8">CopyTo</a> (Array array, int arrayIndex)</td></tr>
<tr class="memdesc:afeae965977197f0b6934cbcab2ff38d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#afeae965977197f0b6934cbcab2ff38d8">More...</a><br /></td></tr>
<tr class="separator:afeae965977197f0b6934cbcab2ff38d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48e0b8ccbfc0d541cdbfce8f38c9ed"><td class="memItemLeft" align="right" valign="top">delegate bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">Equality</a> (object object1, object object2)</td></tr>
<tr class="memdesc:a2a48e0b8ccbfc0d541cdbfce8f38c9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an equality for two objects  <a href="#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">More...</a><br /></td></tr>
<tr class="separator:a2a48e0b8ccbfc0d541cdbfce8f38c9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944a89a526718b042348d4ab8ed04701"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a944a89a526718b042348d4ab8ed04701">Equals</a> (object obj)</td></tr>
<tr class="memdesc:a944a89a526718b042348d4ab8ed04701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object.Equals() override.  <a href="#a944a89a526718b042348d4ab8ed04701">More...</a><br /></td></tr>
<tr class="separator:a944a89a526718b042348d4ab8ed04701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3851426be9b0553574468c7afa9f2d7"><td class="memItemLeft" align="right" valign="top">IEnumerator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#ae3851426be9b0553574468c7afa9f2d7">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:ae3851426be9b0553574468c7afa9f2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList.IEnumerable implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#ae3851426be9b0553574468c7afa9f2d7">More...</a><br /></td></tr>
<tr class="separator:ae3851426be9b0553574468c7afa9f2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085e831ee87635473a8df6f49077242"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#ac085e831ee87635473a8df6f49077242">GetHashCode</a> ()</td></tr>
<tr class="memdesc:ac085e831ee87635473a8df6f49077242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object.GetHashCode() override.  <a href="#ac085e831ee87635473a8df6f49077242">More...</a><br /></td></tr>
<tr class="separator:ac085e831ee87635473a8df6f49077242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c180db50522de43594da5afb4ae6e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#ae3c180db50522de43594da5afb4ae6e2">Heap</a> ()</td></tr>
<tr class="memdesc:ae3c180db50522de43594da5afb4ae6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Since no IComparer is provided here, added objects must implement the IComparer interface.  <a href="#ae3c180db50522de43594da5afb4ae6e2">More...</a><br /></td></tr>
<tr class="separator:ae3c180db50522de43594da5afb4ae6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fa4409f6ffdbe880a1261d42e22a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a07fa4409f6ffdbe880a1261d42e22a8c">Heap</a> (int capacity)</td></tr>
<tr class="memdesc:a07fa4409f6ffdbe880a1261d42e22a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Since no IComparer is provided, added objects must implement the IComparer interface.  <a href="#a07fa4409f6ffdbe880a1261d42e22a8c">More...</a><br /></td></tr>
<tr class="separator:a07fa4409f6ffdbe880a1261d42e22a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71540b3fbcbdfbfa4b336a6843e44326"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a71540b3fbcbdfbfa4b336a6843e44326">Heap</a> (IComparer comparer)</td></tr>
<tr class="memdesc:a71540b3fbcbdfbfa4b336a6843e44326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a71540b3fbcbdfbfa4b336a6843e44326">More...</a><br /></td></tr>
<tr class="separator:a71540b3fbcbdfbfa4b336a6843e44326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72c0c94ca1c8e7569bab452d0c1a6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a3a72c0c94ca1c8e7569bab452d0c1a6b">Heap</a> (IComparer comparer, int capacity)</td></tr>
<tr class="memdesc:a3a72c0c94ca1c8e7569bab452d0c1a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a3a72c0c94ca1c8e7569bab452d0c1a6b">More...</a><br /></td></tr>
<tr class="separator:a3a72c0c94ca1c8e7569bab452d0c1a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d123f4765f8f13fa03abbce8e373c7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e">IndexOf</a> (object obj)</td></tr>
<tr class="memdesc:a9d123f4765f8f13fa03abbce8e373c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Returns the index of the specified object in the list. If the list is sorted, a &lt;see cref = &quot;ArrayList.BinarySearch&quot;&gt;BinarySearch&lt;/see&gt; is performed using IComparer interface. Else the &lt;see cref = &quot;Equals&quot;&gt;Object.Equals&lt;/see&gt; implementation of objects is used.  <a href="#a9d123f4765f8f13fa03abbce8e373c7e">More...</a><br /></td></tr>
<tr class="separator:a9d123f4765f8f13fa03abbce8e373c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f9128de514afc3372982ff3249b88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#ae53f9128de514afc3372982ff3249b88">IndexOf</a> (object obj, int start)</td></tr>
<tr class="memdesc:ae53f9128de514afc3372982ff3249b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but starting at a specified position in the list  <a href="#ae53f9128de514afc3372982ff3249b88">More...</a><br /></td></tr>
<tr class="separator:ae53f9128de514afc3372982ff3249b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8307483b72a281819b56de9606a969be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a8307483b72a281819b56de9606a969be">IndexOf</a> (object obj, <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">Equality</a> areEqual)</td></tr>
<tr class="memdesc:a8307483b72a281819b56de9606a969be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but with a specified equality function  <a href="#a8307483b72a281819b56de9606a969be">More...</a><br /></td></tr>
<tr class="separator:a8307483b72a281819b56de9606a969be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f718ae6adf789b5d621a8bc5deb5e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a8f718ae6adf789b5d621a8bc5deb5e76">IndexOf</a> (object obj, int start, <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">Equality</a> areEqual)</td></tr>
<tr class="memdesc:a8f718ae6adf789b5d621a8bc5deb5e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but with a start index and a specified equality function  <a href="#a8f718ae6adf789b5d621a8bc5deb5e76">More...</a><br /></td></tr>
<tr class="separator:a8f718ae6adf789b5d621a8bc5deb5e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eb0887f5cb6ceb310d14d3a0d50ae6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a88eb0887f5cb6ceb310d14d3a0d50ae6">IndexOfMax</a> ()</td></tr>
<tr class="memdesc:a88eb0887f5cb6ceb310d14d3a0d50ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object of the list whose value is maximum  <a href="#a88eb0887f5cb6ceb310d14d3a0d50ae6">More...</a><br /></td></tr>
<tr class="separator:a88eb0887f5cb6ceb310d14d3a0d50ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cd53685da8c0ba3cc2bf2a01db38cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#ab4cd53685da8c0ba3cc2bf2a01db38cf">IndexOfMin</a> ()</td></tr>
<tr class="memdesc:ab4cd53685da8c0ba3cc2bf2a01db38cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object of the list whose value is minimum  <a href="#ab4cd53685da8c0ba3cc2bf2a01db38cf">More...</a><br /></td></tr>
<tr class="separator:ab4cd53685da8c0ba3cc2bf2a01db38cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac544418a1b3e8061d695e4d650e08da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#aac544418a1b3e8061d695e4d650e08da">Insert</a> (int index, object obj)</td></tr>
<tr class="memdesc:aac544418a1b3e8061d695e4d650e08da"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Cannot be used on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.  <a href="#aac544418a1b3e8061d695e4d650e08da">More...</a><br /></td></tr>
<tr class="separator:aac544418a1b3e8061d695e4d650e08da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f11791d297b8ab63eb58109f9026f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#aa1f11791d297b8ab63eb58109f9026f1">InsertRange</a> (int index, ICollection coll)</td></tr>
<tr class="memdesc:aa1f11791d297b8ab63eb58109f9026f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cannot be called on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.  <a href="#aa1f11791d297b8ab63eb58109f9026f1">More...</a><br /></td></tr>
<tr class="separator:aa1f11791d297b8ab63eb58109f9026f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5fc4870be595daab52cf6073ff5cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a4f5fc4870be595daab52cf6073ff5cbb">LimitOccurrences</a> (object value, int numberToKeep)</td></tr>
<tr class="memdesc:a4f5fc4870be595daab52cf6073ff5cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits the number of occurrences of a specified value. Same values are equals according to the <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a944a89a526718b042348d4ab8ed04701" title="Object.Equals() override. ">Equals()</a> method of objects in the list. The first occurrences encountered are kept.  <a href="#a4f5fc4870be595daab52cf6073ff5cbb">More...</a><br /></td></tr>
<tr class="separator:a4f5fc4870be595daab52cf6073ff5cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc785bd53619cd2353224ee0ab235764"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#adc785bd53619cd2353224ee0ab235764">Pop</a> ()</td></tr>
<tr class="memdesc:adc785bd53619cd2353224ee0ab235764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topmost object on the list and removes it from the list  <a href="#adc785bd53619cd2353224ee0ab235764">More...</a><br /></td></tr>
<tr class="separator:adc785bd53619cd2353224ee0ab235764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9527d6ff81fc555fb6a845d764f29d36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9527d6ff81fc555fb6a845d764f29d36">Push</a> (object obj)</td></tr>
<tr class="memdesc:a9527d6ff81fc555fb6a845d764f29d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes an object on list. It will be inserted at the right spot.  <a href="#a9527d6ff81fc555fb6a845d764f29d36">More...</a><br /></td></tr>
<tr class="separator:a9527d6ff81fc555fb6a845d764f29d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2268fe1763712292285f1964c2a10db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2268fe1763712292285f1964c2a10db8">Remove</a> (object value)</td></tr>
<tr class="memdesc:a2268fe1763712292285f1964c2a10db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a2268fe1763712292285f1964c2a10db8">More...</a><br /></td></tr>
<tr class="separator:a2268fe1763712292285f1964c2a10db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4854afb7890582f3188c8810b36773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a6b4854afb7890582f3188c8810b36773">RemoveAt</a> (int index)</td></tr>
<tr class="memdesc:a6b4854afb7890582f3188c8810b36773"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a6b4854afb7890582f3188c8810b36773">More...</a><br /></td></tr>
<tr class="separator:a6b4854afb7890582f3188c8810b36773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be45d60b7fad6e6a447f2362234f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a97be45d60b7fad6e6a447f2362234f77">RemoveDuplicates</a> ()</td></tr>
<tr class="memdesc:a97be45d60b7fad6e6a447f2362234f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all duplicates in the list. Each value encountered will have only one representant  <a href="#a97be45d60b7fad6e6a447f2362234f77">More...</a><br /></td></tr>
<tr class="separator:a97be45d60b7fad6e6a447f2362234f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa711f63f3051ff67f8268a3897e665e9"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#aa711f63f3051ff67f8268a3897e665e9">ToString</a> ()</td></tr>
<tr class="memdesc:aa711f63f3051ff67f8268a3897e665e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object.ToString() override. Build a string to represent the list.  <a href="#aa711f63f3051ff67f8268a3897e665e9">More...</a><br /></td></tr>
<tr class="separator:aa711f63f3051ff67f8268a3897e665e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a8869912175dc27009215433ef0ffa289"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a8869912175dc27009215433ef0ffa289">AddDuplicates</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a8869912175dc27009215433ef0ffa289"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, it will not be possible to add an object to the list if its value is already in the list.  <a href="#a8869912175dc27009215433ef0ffa289">More...</a><br /></td></tr>
<tr class="separator:a8869912175dc27009215433ef0ffa289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7ad49b2f6d09a777985f210494340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#aa8a7ad49b2f6d09a777985f210494340">Capacity</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aa8a7ad49b2f6d09a777985f210494340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idem <a class="el" href="../../">ArrayList</a>  <a href="#aa8a7ad49b2f6d09a777985f210494340">More...</a><br /></td></tr>
<tr class="separator:aa8a7ad49b2f6d09a777985f210494340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e354c1814163ce5647da58a3976e4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a07e354c1814163ce5647da58a3976e4e">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a07e354c1814163ce5647da58a3976e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a07e354c1814163ce5647da58a3976e4e">More...</a><br /></td></tr>
<tr class="separator:a07e354c1814163ce5647da58a3976e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290c72c2d86157541ff128c9a6587f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a290c72c2d86157541ff128c9a6587f00">IsFixedSize</a><code> [get]</code></td></tr>
<tr class="memdesc:a290c72c2d86157541ff128c9a6587f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a290c72c2d86157541ff128c9a6587f00">More...</a><br /></td></tr>
<tr class="separator:a290c72c2d86157541ff128c9a6587f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5f3e0509f3317508e0f35ca20c0d9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a3a5f3e0509f3317508e0f35ca20c0d9e">IsReadOnly</a><code> [get]</code></td></tr>
<tr class="memdesc:a3a5f3e0509f3317508e0f35ca20c0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a3a5f3e0509f3317508e0f35ca20c0d9e">More...</a><br /></td></tr>
<tr class="separator:a3a5f3e0509f3317508e0f35ca20c0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e13585f367bf5addc8e376c5e77e278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a6e13585f367bf5addc8e376c5e77e278">IsSynchronized</a><code> [get]</code></td></tr>
<tr class="memdesc:a6e13585f367bf5addc8e376c5e77e278"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a6e13585f367bf5addc8e376c5e77e278">More...</a><br /></td></tr>
<tr class="separator:a6e13585f367bf5addc8e376c5e77e278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e07a5762deac7e5590f1d5b75d81614"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a1e07a5762deac7e5590f1d5b75d81614">SyncRoot</a><code> [get]</code></td></tr>
<tr class="memdesc:a1e07a5762deac7e5590f1d5b75d81614"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a>  <a href="#a1e07a5762deac7e5590f1d5b75d81614">More...</a><br /></td></tr>
<tr class="separator:a1e07a5762deac7e5590f1d5b75d81614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe36db7876d4956a884634c9dc8126c"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#adbe36db7876d4956a884634c9dc8126c">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:adbe36db7876d4956a884634c9dc8126c"><td class="mdescLeft">&#160;</td><td class="mdescRight">IList implementation. Gets object's value at a specified index. The set operation is impossible on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.  <a href="#adbe36db7876d4956a884634c9dc8126c">More...</a><br /></td></tr>
<tr class="separator:adbe36db7876d4956a884634c9dc8126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a> allows to maintain a list sorted as long as needed. If no IComparer interface has been provided at construction, then the list expects the Objects to implement IComparer. If the list is not sorted it behaves like an ordinary list. When sorted, the list's "Add" method will put new objects at the right place. As well the "Contains" and "IndexOf" methods will perform a binary search. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae3c180db50522de43594da5afb4ae6e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WhiteCore.BotManager.AStar.Heap.Heap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Since no IComparer is provided here, added objects must implement the IComparer interface. </p>

</div>
</div>
<a class="anchor" id="a07fa4409f6ffdbe880a1261d42e22a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WhiteCore.BotManager.AStar.Heap.Heap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Since no IComparer is provided, added objects must implement the IComparer interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Capacity of the list (<a class="el" href="../../">ArrayList.Capacity</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71540b3fbcbdfbfa4b336a6843e44326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WhiteCore.BotManager.AStar.Heap.Heap </td>
          <td>(</td>
          <td class="paramtype">IComparer&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>Will be used to compare added elements for sort and search operations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a72c0c94ca1c8e7569bab452d0c1a6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WhiteCore.BotManager.AStar.Heap.Heap </td>
          <td>(</td>
          <td class="paramtype">IComparer&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>Will be used to compare added elements for sort and search operations.</td></tr>
    <tr><td class="paramname">capacity</td><td>Capacity of the list (<a class="el" href="../../">ArrayList.Capacity</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4bd884c3d4826e1d566fbca5a63afa65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.Add </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Adds the object at the right place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the object has been added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a> is set to use object's IComparable interface, and the specified object does not implement this interface.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30c6e8ddd1a1953168ccd04cc343d308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.AddRange </td>
          <td>(</td>
          <td class="paramtype">ICollection&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The objects will be added at the right place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>The object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the object has been added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a> is set to use object's IComparable interface, and the specified object does not implement this interface.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43688c29ebea70bc234c39fab7de8af5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a9cc47c6f9c9465558869d4d1c0a357db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object WhiteCore.BotManager.AStar.Heap.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ICloneable implementation. Idem <a class="el" href="../../">ArrayList</a> </p>
<dl class="section return"><dt>Returns</dt><dd>Cloned object.</dd></dl>

</div>
</div>
<a class="anchor" id="a3fceb7f39ee8ceee1f502e1903db26b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WhiteCore.BotManager.AStar.Heap.Contains </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Search for a specified object in the list. If the list is sorted, a &lt;see cref = &quot;ArrayList.BinarySearch&quot;&gt;BinarySearch&lt;/see&gt; is performed using IComparer interface. Else the &lt;see cref = &quot;Equals&quot;&gt;Object.Equals&lt;/see&gt; implementation is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is in the list, otherwise false.</dd></dl>

</div>
</div>
<a class="anchor" id="afeae965977197f0b6934cbcab2ff38d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.CopyTo </td>
          <td>(</td>
          <td class="paramtype">Array&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td></td></tr>
    <tr><td class="paramname">arrayIndex</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a48e0b8ccbfc0d541cdbfce8f38c9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate bool WhiteCore.BotManager.AStar.Heap.Equality </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an equality for two objects </p>

</div>
</div>
<a class="anchor" id="a944a89a526718b042348d4ab8ed04701"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool WhiteCore.BotManager.AStar.Heap.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object.Equals() override. </p>
<dl class="section return"><dt>Returns</dt><dd>true if object is equal to this, otherwise false.</dd></dl>

</div>
</div>
<a class="anchor" id="ae3851426be9b0553574468c7afa9f2d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerator WhiteCore.BotManager.AStar.Heap.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList.IEnumerable implementation. Idem <a class="el" href="../../">ArrayList</a> </p>
<dl class="section return"><dt>Returns</dt><dd>Enumerator on the list.</dd></dl>

</div>
</div>
<a class="anchor" id="ac085e831ee87635473a8df6f49077242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override int WhiteCore.BotManager.AStar.Heap.GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object.GetHashCode() override. </p>
<dl class="section return"><dt>Returns</dt><dd>Hash code for this.</dd></dl>

</div>
</div>
<a class="anchor" id="a9d123f4765f8f13fa03abbce8e373c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOf </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Returns the index of the specified object in the list. If the list is sorted, a &lt;see cref = &quot;ArrayList.BinarySearch&quot;&gt;BinarySearch&lt;/see&gt; is performed using IComparer interface. Else the &lt;see cref = &quot;Equals&quot;&gt;Object.Equals&lt;/see&gt; implementation of objects is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the object has been found, a positive integer corresponding to its position. If the objects has not been found, a negative integer which is the bitwise complement of the index of the next element. </dd></dl>

</div>
</div>
<a class="anchor" id="ae53f9128de514afc3372982ff3249b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOf </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but starting at a specified position in the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to locate.</td></tr>
    <tr><td class="paramname">start</td><td>The index for start position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8307483b72a281819b56de9606a969be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOf </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">Equality</a>&#160;</td>
          <td class="paramname"><em>areEqual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but with a specified equality function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to locate.</td></tr>
    <tr><td class="paramname">areEqual</td><td>Equality function to use for the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8f718ae6adf789b5d621a8bc5deb5e76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOf </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a2a48e0b8ccbfc0d541cdbfce8f38c9ed">Equality</a>&#160;</td>
          <td class="paramname"><em>areEqual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idem <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a9d123f4765f8f13fa03abbce8e373c7e" title="IList implementation. Returns the index of the specified object in the list. If the list is sorted...">IndexOf(object)</a>, but with a start index and a specified equality function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to locate.</td></tr>
    <tr><td class="paramname">start</td><td>The index for start position.</td></tr>
    <tr><td class="paramname">areEqual</td><td>Equality function to use for the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a88eb0887f5cb6ceb310d14d3a0d50ae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOfMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object of the list whose value is maximum </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum object in the list</dd></dl>

</div>
</div>
<a class="anchor" id="ab4cd53685da8c0ba3cc2bf2a01db38cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.IndexOfMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object of the list whose value is minimum </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum object in the list</dd></dl>

</div>
</div>
<a class="anchor" id="aac544418a1b3e8061d695e4d650e08da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Cannot be used on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index before which the object must be added.</td></tr>
    <tr><td class="paramname">obj</td><td>The object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Insert method cannot be called on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1f11791d297b8ab63eb58109f9026f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.InsertRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICollection&#160;</td>
          <td class="paramname"><em>coll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cannot be called on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index before which the objects must be added.</td></tr>
    <tr><td class="paramname">coll</td><td>The object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Insert cannot be called on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f5fc4870be595daab52cf6073ff5cbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.LimitOccurrences </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberToKeep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Limits the number of occurrences of a specified value. Same values are equals according to the <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html#a944a89a526718b042348d4ab8ed04701" title="Object.Equals() override. ">Equals()</a> method of objects in the list. The first occurrences encountered are kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value whose occurrences number must be limited.</td></tr>
    <tr><td class="paramname">numberToKeep</td><td>Number of occurrences to keep</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc785bd53619cd2353224ee0ab235764"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object WhiteCore.BotManager.AStar.Heap.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the topmost object on the list and removes it from the list </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the topmost object on the list</dd></dl>

</div>
</div>
<a class="anchor" id="a9527d6ff81fc555fb6a845d764f29d36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.Push </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes an object on list. It will be inserted at the right spot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to add to the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2268fe1763712292285f1964c2a10db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.Remove </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Idem <a class="el" href="../../">ArrayList</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object whose value must be removed if found in the list.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b4854afb7890582f3188c8810b36773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Idem <a class="el" href="../../">ArrayList</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of object to remove.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97be45d60b7fad6e6a447f2362234f77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WhiteCore.BotManager.AStar.Heap.RemoveDuplicates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all duplicates in the list. Each value encountered will have only one representant </p>

</div>
</div>
<a class="anchor" id="aa711f63f3051ff67f8268a3897e665e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override string WhiteCore.BotManager.AStar.Heap.ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object.ToString() override. Build a string to represent the list. </p>
<dl class="section return"><dt>Returns</dt><dd>The string reflecting the list.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a8869912175dc27009215433ef0ffa289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WhiteCore.BotManager.AStar.Heap.AddDuplicates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true, it will not be possible to add an object to the list if its value is already in the list. </p>

</div>
</div>
<a class="anchor" id="aa8a7ad49b2f6d09a777985f210494340"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a07e354c1814163ce5647da58a3976e4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WhiteCore.BotManager.AStar.Heap.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a290c72c2d86157541ff128c9a6587f00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WhiteCore.BotManager.AStar.Heap.IsFixedSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a3a5f3e0509f3317508e0f35ca20c0d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WhiteCore.BotManager.AStar.Heap.IsReadOnly</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a6e13585f367bf5addc8e376c5e77e278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WhiteCore.BotManager.AStar.Heap.IsSynchronized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="a1e07a5762deac7e5590f1d5b75d81614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object WhiteCore.BotManager.AStar.Heap.SyncRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList.ICollection implementation. Idem <a class="el" href="../../">ArrayList</a> </p>

</div>
</div>
<a class="anchor" id="adbe36db7876d4956a884634c9dc8126c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object WhiteCore.BotManager.AStar.Heap.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IList implementation. Gets object's value at a specified index. The set operation is impossible on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Index is less than zero or Index is greater than Count.</td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>[] operator cannot be used to set a value on a <a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html" title="The Heap allows to maintain a list sorted as long as needed. If no IComparer interface has been provi...">Heap</a>.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>WhiteCore/BotManager/AStar/Heap.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dc/dc7/namespaceWhiteCore.html">WhiteCore</a></li><li class="navelem"><a class="el" href="../../de/d65/namespaceWhiteCore_1_1BotManager.html">BotManager</a></li><li class="navelem"><a class="el" href="../../d1/df0/namespaceWhiteCore_1_1BotManager_1_1AStar.html">AStar</a></li><li class="navelem"><a class="el" href="../../dc/da2/classWhiteCore_1_1BotManager_1_1AStar_1_1Heap.html">Heap</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
